\section{Le Méta-Modèle Cinématique}
Le métamodèle cinématique est organisé autour de trois principaux packages:
\begin{itemize}
  \item \textbf{Toolkit}: représente les concepts liés à la définition des widgets\footnote{Elément visuel d'une interface graphique (bouton, ascenseur,liste déroulante, etc.)} \textsc{ihm}.
\newline
Le package Toolkit est construit de la manière suivante:
\newline
\begin{figure}[htb]
  \centering
  \includegraphics[scale=.3]{img/toolkit.eps}
  \caption{Métamodèle toolkit}
  \label{fig:Métamodèle Toolkit}
\end{figure}
  \item \textbf{View}: représente les concepts liés à la définition des écrans \textsc{ihm}.
\newline
Le package View est construit de la manière suivante:
\newline
\begin{figure}[H]
  \centering
  \includegraphics[scale=.3]{img/view.eps}
  \caption{Métamodèle view}
  \label{fig:Métamodèle View}
\end{figure}
  \item \textbf{Flow}: permet d'identifier le comportement dynamique des écrans \textsc{ihm}. Le flow peut être appréhendé comme une sorte de diagramme d'activités.
\newline
Le package Flow est construit de la manière suivante:
\newline
\begin{figure}[H]
  \centering
  \includegraphics[scale=.3]{img/flow.eps}
  \caption{Métamodèle flow}
  \label{fig:Métamodèle Flow}
\end{figure}
\end{itemize}
\subsection{Le concept cinématique dans \kwplay{}}
Nous retrouvons dans \kwplay{} un repertoire dans lequel sont regroupés les différents fichiers Web (HTML, XML, …) liés aux vues (principe MVC). Les fichiers relatifs à la création des \textsc{ihm} sont donc indépendants du reste de l'application.   
\subsection{Conception du modèle}
La modélisation \textsc{ihm} de l'application prototype \texttt{Play} a été mise en place à l'aide de l'outil Acceleo. Le modèle est construit autour des trois principes du métamodèle défini précédemment:
\begin{enumerate}
\item \textbf{Toolkit}: Représente une palette contenant des widgets. Nous avons utilisé le modèle Toolkit (par défaut) car il couvre tous les éléments de type \guim{widget web}  actuellement existants (bouton, liste déroulante, champ de saisie, tableau, etc.). Chaque élément \guim{widget} peut lever des événements de type \textit{WidgetEventType} (onClick(), onFocus()...).
\item \textbf{View} : Permet de représenter tous les éléments graphiques d'une interface utilisateur. Au plus haut niveau, nous définissons les éléments de type \textit{View Container}. 
\newline
Un \textit{View Container} peut être de type \textit{Page}, \textit{Panel} (ou \guim{Formulaire}) ou \textit{Table}. 
\newline
Nous choisissons le type \textit{Page} pour représenter un écran \textsc{ihm}. Pour chaque ViewContainer, sont ensuite définis les éléments qu'il contient, qui peuvent être des formulaires, des tableaux, ou des widgets simples. Nos écrans sont alors construits de manière progressive jusqu'à obtenir toutes les fenêtres \textsc{ihm} qui composent l'application.
\begin{figure}[H]
  \centering
  \includegraphics[scale=.4]{img/views.eps}
  \caption{Construction du modèle (partie Views)}
  \label{fig:Construction du modèle (partie Views)}
\end{figure}
\item \textbf{Flow} : Représente la manière dont les écrans de l'application peuvent s'enchaîner. Il décrit le comportement dynamique de l'\textsc{ihm} sous la forme d'enchaînements entre des états. Nous définissons ici, un état initial \textit{Initial State Start}, des états \textit{View State}, des états d'action \textit{Action State} et des transitions :
\begin{itemize}
\item Les états \textit{View State} correspondent aux écrans \textsc{ihm} et contiennent les \textit{View Container} décrit précédemment.
\item Les états d'action \textit{Action State} définissent les actions à réaliser sur chaque écran de l'application. Ils sont liés aux fonctions offertes par la partie \kwsoa{}. 
\newline
\textit{Exemple}: Pour le chargement de la liste des produits disponibles pour la page d'accueil (ou Vitrine), nous définissons un \textit{Action State} nommé \guim{Load Public Product List} que nous lions à l'opération getProductList() offerte par \kwsoa{}.  
\item Les transitions \guim{(\textit{Transition})} font passer l'\textsc{ihm} d'un état à un autre (d'un écran à un autre). Ils font également le lien entre les Action States et les View States. 
\newline
\textit{Exemple}: Une transition pour l'affichage de l'écran d'accueil \guim{Display Main Page} va de l'état \guim{Action State Load Public Product List} (chargement des éléments de la page \guim{Vitrine}) à l'état \guim{View State Display MainPage} (affichage de la page \guim{Vitrine}).
\newline
Les transitions peuvent également avoir des conditions de garde, déterminées par des View Events (elles n'occurrent ainsi que si les conditions d'activation sont remplies).
\end{itemize}
\end{enumerate}       
\subsection{Génération du code}
Dans cette partie, nous nous occupons de générer les fichiers relatifs aux \guim{routes}, aux \guim{controllers} et les \guim{views}. Rappelons les caractéristiques de chaque type de fichier:
\begin{itemize}
\item \textbf{Controller}: Nous avons une classe \guim{MainController} dans laquelle sont déclarées des méthodes statiques pour chacune de nos Actions;
\item \textbf{Route}: Fichier de configuration des routes au sein de l'application. Les \guim{routes} sont toutes associées au même controleur : \guim{MainController}. 
\item \textbf{View}: Ensemble de fichiers décrivant un moteur de templates qui repose entièrement sur Scala ainsi que du code html pour la définition des formulaires, widgets, etc. 
\end{itemize}
Le Générateur \guim{Cinematic} se divise ainsi en un fichier de génération principal, GenerateCinematic, lié aux fichiers de génération majeurs (un pour chaque type de fichiers - Controller, Route, View), eux-même appelant des fichiers secondaires comportant les templates et queries nécessaires à l'élaboration des fichiers finaux en Scala et HTML.
\begin{figure}[H]
  \centering
  \includegraphics[scale=.35]{img/hierarchie.eps}
  \caption{Hierarchie des fichiers générateurs. Chaque ellipse correspond à un générateur \guim{principal}, et chaque rectangle à un fichier de templates secondaire.}
  \label{fig: hierarchie generateurs}
\end{figure}
A partir d'un Modèle composé comme décrit précédemment, le Générateur va analyser chacun de ses éléments et, à l'aide des templates correspondants, les traduire afin de créer les fichiers Scala/HTML finaux. 
\newline
Le générateur de Routes analysera le Flow principal du modèle, et traduira chaque ViewState et ActionState en appels vers des méthodes statiques contenues dans le Controller.
\newline
De même, le générateur de Controller générera, pour chaque ViewState du même Flow principal, l'ensemble des méthodes statiques lui étant associées - ces mêmes méthodes mentionnées dans les Routes.
\newline
Le générateur de Views permet la création des différentes pages de l'application - le modèle entier est analysé afin de permettre la création de chacun des éléments nécessaires à l'IHM. Une application Scala est composée d'une page principale, dite \guim{main} ou \guim{index}, qui fait appel à d'autres pages qui correspondent aux différents écrans de l'application. Ainsi, la page \guim{index}, indépendante des autres écrans, n'est pas représentée dans le modèle - elle est cependant générée automatiquement au début de l'analyse de celui-ci, avant la génération des écrans.
\newline
Chaque page est décrite au sein d'un ViewState (écran) par l'intermédiaire d'un ViewContainer de type \guim{Page}. Dans notre modèle actuel, il est supposé qu'un ViewState ne contient qu'un seul ViewContainer de type \guim{Page} (un écran = une page); de cette manière, un seul fichier Scala/HTML est créé par ViewState, et donc par écran. Le ViewContainer \guim{Page} peut contenir à son tour soit d'autres ViewContainers (qui sont alors soit des \guim{Panels} - formulaires - soit des \guim{Tables}), soit des ViewElements (qui sont en réalité des Widgets). Le rôle du générateur de Views est de traduire chacun de ces éléments dans les fichiers Scala/HTML de chaque écran.
\newline
Toute page du modèle est créée selon les étapes d'analyse d'élément suivantes :
\begin{enumerate}
\item CinematicRoot (le modèle) : récupération et analyse de chaque ViewState tour à tour.
\item ViewState : récupération du ViewContainer \guim{Page} correspondant à l'écran souhaité.
\item ViewContainer \guim{Page}: récupération et analyse de chaque élément contenu (ViewContainers secondaires ou ViewElements).
\item ViewContainer secondaire : \guim{Table} ou \guim{Panel} - traduction du conteneur dans les fichiers finaux (création de formulaire ou de tableau html), et analyse des ViewElements qu'il contient.
\item ViewElement : traduction de chaque type de ViewElement en widget Scala/HTML dans les fichiers finaux (création de champs de saisie, de boutons...).
\end{enumerate}
Plutôt que de créer un template par type d'élément, nous avons créé des templates \guim{conditionnels}. Ainsi, par exemple, pour la génération de ViewElements, un seul Template est appelé - cependant, selon la nature du ViewElement (déterminée par une Query), une seule des spécifications du Template sera mise en oeuvre. Il en est de même pour les ViewContainers secondaires. De cette façon, un code \guim{personnalisé} pour chaque élément est généré, prenant en compte le type de l'élément, son environnement (conteneur) et ses propriétés (label...).
\newline
\begin{figure}[H]
  \centering
  \includegraphics[scale=.35]{img/viewexample.eps}
  \caption{Exemple d'analyse par le générateur de views.}
  \label{fig: exemple generateur view}
\end{figure}
\paragraph{Méthodes}
Certains éléments, tels que les formulaires et les boutons, requièrent l'utilisation de méthodes (envoi de données par exemple). Ces opérations ne peuvent être récupérées directement à partir d'un élément d'un ViewContainer; il faut utiliser les Transitions. 
\newline
De l'élément du ViewContainer analysé, on récupère un ViewEvent. Ce ViewEvent est spécifique à cet élément. Pour pouvoir récupérer la méthode correspondante, il faut alors parcourir le Flow principal, et récupérer la Transition comportant ce même ViewEvent. Cette transition lie l'écran d'où est issu l'élément, et l'ActionState correspondant. Cet ActionState est défini avec un FlowAction, et c'est ce FlowAction qui contient la signature de la méthode à utiliser (Operation). Le générateur peut alors compléter le code créé pour l'élément dans le fichier final de l'écran, et dans les fichiers du Controller et des Routes, référençant la méthode.


\subsection{Résultats obtenus}
Suite au lancement de la génération du code à partir d'un modèle cinematic valide, on obtient divers fichiers Scala/HTML compatibles Play!, généré dans des dossiers précis.
\begin{itemize}
\item Les Views : dans le dossier /app/views ont été générés le fichier de la page d'index, ainsi qu'un fichier par ViewState contenu dans le modèle.
\item Le Controller : dans le dossier /app/controllers se trouve le fichier Controller, comportant les différentes opérations référencées dans les ActionStates.
\item Les routes : enfin, dans le dossier /conf, se trouve le fichier référençant les \guim{routes} reliant aux opérations contenues dans le Controller.
\end{itemize}
L'indentation et les espaces réservés au code utilisateurs sont des parties à prendre en compte dans le générateur. Les fichiers créés, bien que personnalisés selon les attributs du modèle, restent très génériques; la modification d'un template peut provoquer une perte de qualité du code généré; de même, si l'application générée est compatible avec play!, il est du ressort de l'utilisateur de s'assurer que le modèle qu'il propose ou les modifications qu'il apporte au code ne perturbent pas son fonctionnement, au risque de corrompre certaines fonctionnalités.
\newline
L'application lancée sur Play!, on peut souhaiter améliorer son ergonomie en ajoutant des Header et Footer à chaque page. La gestion de écrans se faisant à partir de la page d'index, les éléments qui précèdent le bloc de contenu et ceux qui le suivent sont préservés sur toutes les pages. Ainsi, si l'utilisateur veut créer un Header présentant des liens vers différentes pages de son application, plusieurs solutions s'offrent à lui : il peut modifier son modèle de telle sorte que les pages à référencer soient mises en valeur, avec un attribut spécial par exemple ; il peut modifier le générateur, et faire prendre en compte un ViewState spécialisé pour le Header; il peut également créer ses propres widgets et les inclure dans le générateur après modification du métamodèle. D'autres possibilités permettent de gérer cette amélioration - la plus simple étant la première, se gérant avec un simple ajout de templates gérant la génération d'une liste de liens répondant aux critères définis par l'utilisateur au préalable.